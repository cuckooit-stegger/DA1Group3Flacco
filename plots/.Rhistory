#normal scale and log scale
layout(matrix(1:2, ncol=2))
plot(wss, type="b", main=paste("WSS of kmeans for ", main), xlab="Num of clusters", ylab="WSS")
plot(log(wss), type="b", main=paste("log(WSS) of kmeans for ", main), xlab="Num of clusters", ylab="log(WSS)")
if(pdf.create == T) {     dev.off()   }
}
#custom function for creating dendrograms with agglomerative clustering to the
#methods defind in the parameter settings
aggl_dend.custom <- function(data, methods=c("single", "complete", "average", "centroid", "ward.D", "ward.D2")) {
#reset window settings
par.reset(main = "Dendrograms")
#set margin settings and layout
par(mar = c(0, 5, 4, 2) + 0.1)
layout(matrix(1:6, ncol=3, byrow=TRUE))
#create dendrograms applying different methods
sapply(methods,
function(x) plot(hclust(dist(data), x),
hang = -1,
labels = FALSE,
las = 1,
xlab = "",
sub = "",
main = paste("Cluster Dendrogram(", x,
" linkage)"),
cex = 1, cex.axis = 1, cex.lab = 1, cex.main = 1))
if(pdf.create == T) {     dev.off()   }
}
#funtion for creating corrleation metrix by using ggplot2
# Get lower triangle of the correlation matrix
get_lower_tri<-function(x){
x[upper.tri(x)] <- NA
return(x)
}
# Get upper triangle of the correlation matrix
get_upper_tri <- function(x){
x[lower.tri(x)]<- NA
return(x)
}
# Reorder the correlation matrix and alter the shape of correlation data into triangle form
reorder_cormat <- function(x){
# Use correlation between variables as distance
dd <- as.dist((1-x)/2)
hc <- hclust(dd)
x <- x[hc$order, hc$order]
}
# Creating correlation matrix which is reordered with upper triple form
library(reshape2)
reorder_correlation <- function(x){
x <- reorder_cormat(x)
y <- get_upper_tri(x)
return(y)
}
# Create a ggheatmap
ggheatmap <- function(x, t){
ggplot(x, aes(Var2, Var1, fill = value))+
geom_tile(color = "white")+
scale_fill_gradient2(low = "blue", high = "red", mid = "white",
midpoint = 0, limit = c(-1,1), space = "Lab",
name="Pearson\nCorrelation") +
theme_minimal()+ # minimal theme
theme(axis.text.x = element_text(angle = 45, vjust = 1,
size = 12, hjust = 1))+
coord_fixed()+ #add correlation coefficients on the heatmap
geom_text(aes(Var2, Var1, label = value), color = "black", size = 3) +
theme(
axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.grid.major = element_blank(),
panel.border = element_blank(),
panel.background = element_blank(),
axis.ticks = element_blank(),
legend.justification = c(1, 0),
legend.position = c(0.6, 0.7),
legend.direction = "horizontal")+
guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
title.position = "top", title.hjust = 0.5))+
# Input title of the graph
ggtitle(t) + theme(plot.title = element_text(lineheight=.8, face="bold"))
}
heatmap <- function(x, t){
y <- round(cor(x),2)
y <- melt(reorder_correlation(y), na.rm = TRUE)
ggheatmap(y, t="Correlation of Features in the group of ela_conv")
}
#save functions in file for loading them in Part01 and Part02
save(list = ls(all=TRUE), file="../3-customFunctions.RData")
#exclude the technical features at the beginning of the dataset (such as prob.seed or repl) -> first 7 features
#these features are input parameters to the dataset generator and thus not subject to most of further analysis
#in some analysis it is paid attention to and then we will access by getting this information from metadata
#Column 6(topology) is kept in the dataset as it is some feature of the problem instance (see papers)
afeats = feats[,-c(seq(1,5),7)]
metadata = feats[,c(seq(1,5),7)]
#exclude features with variance of zero
#these do not give further information on the problem instances
#furthermore these features will lead to problems in PCA, etc. because the variance cannot be normalized
#following features are excluded due to that:
#cm_angle.costs_fun_evals, cm_conv.costs_fun_evals, cm_grad.costs_fun_evals, ela_conv.lin_prob,
#ela_conv.costs_fun_evals, ela_curv.sample_size, ela_local.n_loc_opt.abs, ela_local.n_loc_opt.rel
var0feats = which(sapply(1:length(afeats), function(x) {var(afeats[,x])}) == 0)
bfeats = afeats[,-var0feats]
#convert categorical var "topology" into numerical equivalent
bfeats[,1] = as.integer(factor(bfeats[,1], labels=c(0,1)))
#set rownames accoring to rownumber
attributes(bfeats)$row.names = as.character(1:nrow(bfeats))
#result is a dataset of 58 expensive features based on the flacco dataset which is used for further tasks
#feature groups (used for detailed inter-group / intra-group analysis)
bfeats.topology = bfeats[,1]
bfeats.cm_angle = bfeats[,seq(2,10)]
bfeats.cm_conv = bfeats[,seq(11,15)]
bfeats.cm_grad = bfeats[,seq(16,18)]
bfeats.ela_conv = bfeats[,seq(19,22)]
bfeats.ela_curv = bfeats[,seq(23,45)]
bfeats.ela_local= bfeats[,seq(46,59)]
afeats = feats[,-c(seq(1,5),7)]
metadata = feats[,c(seq(1,5),7)]
#exclude features with variance of zero
#these do not give further information on the problem instances
#furthermore these features will lead to problems in PCA, etc. because the variance cannot be normalized
#following features are excluded due to that:
#cm_angle.costs_fun_evals, cm_conv.costs_fun_evals, cm_grad.costs_fun_evals, ela_conv.lin_prob,
#ela_conv.costs_fun_evals, ela_curv.sample_size, ela_local.n_loc_opt.abs, ela_local.n_loc_opt.rel
var0feats = which(sapply(1:length(afeats), function(x) {var(afeats[,x])}) == 0)
bfeats = afeats[,-var0feats]
#convert categorical var "topology" into numerical equivalent
bfeats[,1] = as.integer(factor(bfeats[,1], labels=c(0,1)))
#set rownames accoring to rownumber
attributes(bfeats)$row.names = as.character(1:nrow(bfeats))
#result is a dataset of 58 expensive features based on the flacco dataset which is used for further tasks
#feature groups (used for detailed inter-group / intra-group analysis)
bfeats.topology = bfeats[,1]
bfeats.cm_angle = bfeats[,seq(2,10)]
bfeats.cm_conv = bfeats[,seq(11,15)]
bfeats.cm_grad = bfeats[,seq(16,18)]
bfeats.ela_conv = bfeats[,seq(19,22)]
bfeats.ela_curv = bfeats[,seq(23,45)]
bfeats.ela_local= bfeats[,seq(46,59)]
load("../3-flacco1.RData")
str(feats)
summary(feats)
#exclude the technical features at the beginning of the dataset (such as prob.seed or repl) -> first 7 features
#these features are input parameters to the dataset generator and thus not subject to most of further analysis
#in some analysis it is paid attention to and then we will access by getting this information from metadata
#Column 6(topology) is kept in the dataset as it is some feature of the problem instance (see papers)
afeats = feats[,-c(seq(1,5),7)]
metadata = feats[,c(seq(1,5),7)]
#exclude features with variance of zero
#these do not give further information on the problem instances
#furthermore these features will lead to problems in PCA, etc. because the variance cannot be normalized
#following features are excluded due to that:
#cm_angle.costs_fun_evals, cm_conv.costs_fun_evals, cm_grad.costs_fun_evals, ela_conv.lin_prob,
#ela_conv.costs_fun_evals, ela_curv.sample_size, ela_local.n_loc_opt.abs, ela_local.n_loc_opt.rel
var0feats = which(sapply(1:length(afeats), function(x) {var(afeats[,x])}) == 0)
bfeats = afeats[,-var0feats]
#convert categorical var "topology" into numerical equivalent
bfeats[,1] = as.integer(factor(bfeats[,1], labels=c(0,1)))
#set rownames accoring to rownumber
attributes(bfeats)$row.names = as.character(1:nrow(bfeats))
#result is a dataset of 58 expensive features based on the flacco dataset which is used for further tasks
#feature groups (used for detailed inter-group / intra-group analysis)
bfeats.topology = bfeats[,1]
bfeats.cm_angle = bfeats[,seq(2,10)]
bfeats.cm_conv = bfeats[,seq(11,15)]
bfeats.cm_grad = bfeats[,seq(16,18)]
bfeats.ela_conv = bfeats[,seq(19,22)]
bfeats.ela_curv = bfeats[,seq(23,45)]
bfeats.ela_local= bfeats[,seq(46,59)]
ggheatmap(cor.bfeats.cm_conv, t="Correlation of Features in the group of cm_conv")
ggheatmap(bfeats.cm_conv, t="Correlation of Features in the group of cm_conv")
cor.bfeats.cm_conv <- round(cor(bfeats.cm_conv),2)
melted_cor.bfeats.cm_conv <- melt(cor.bfeats.cm_conv)
cor.bfeats.cm_conv <- melt(reorder_correlation(cor.bfeats.cm_conv), na.rm = TRUE)
ggheatmap(cor.bfeats.cm_conv, t="Correlation of Features in the group of cm_conv")
heatmap <- function(x, t){
y <- round(cor(x),2)
y <- melt(y)
y <- melt(reorder_correlation(y), na.rm = TRUE)
ggheatmap(y, t="Correlation of Features in the group of ela_conv")
}
ggheatmap(bfeats.cm_conv, t="Correlation of Features in the group of cm_conv")
library(reshape2)
heatmap <- function(x, t){
y <- round(cor(x),2)
y <- melt(y)
y <- melt(reorder_correlation(y), na.rm = TRUE)
ggheatmap(y, t="Correlation of Features in the group of ela_conv")
}
ggheatmap(bfeats.cm_conv, t="Correlation of Features in the group of cm_conv")
heatmap <- function(x, t){
y <- round(cor(x),2)
z <- melt(y)
z <- melt(reorder_correlation(z), na.rm = TRUE)
ggheatmap(z, t="Correlation of Features in the group of ela_conv")
}
ggheatmap(bfeats.cm_conv, t="Correlation of Features in the group of cm_conv")
cor.bfeats.cm_conv <- round(cor(bfeats.cm_conv),2)
melted_cor.bfeats.cm_conv <- melt(cor.bfeats.cm_conv)
cor.bfeats.cm_conv <- melt(reorder_correlation(cor.bfeats.cm_conv), na.rm = TRUE)
ggheatmap(cor.bfeats.cm_conv, t="Correlation of Features in the group of cm_conv")
cor.bfeats.cm_grad <- round(cor(bfeats.cm_grad),2)
cor.bfeats.cm_grad <- melt(reorder_correlation(cor.bfeats.cm_grad), na.rm = TRUE)
ggheatmap(cor.bfeats.cm_grad, t="Correlation of Features in the group of cm_grad")
heatmap <- function(x, t){
y <- round(cor(x),2)
z <- melt(reorder_correlation(y), na.rm = TRUE)
ggheatmap(z, t="Correlation of Features in the group of ela_conv")
}
ggheatmap(bfeats.cm_conv, t="Correlation of Features in the group of cm_conv")
cor.bfeats.ela_conv <- round(cor(bfeats.ela_conv),2)
cor.bfeats.ela_conv <- melt(reorder_correlation(cor.bfeats.ela_conv), na.rm = TRUE)
ggheatmap(cor.bfeats.ela_conv, t="Correlation of Features in the group of ela_conv")
reorder_correlation(y)
heatmap <- function(x, t){
y <- round(cor(x),2)
y <- melt(reorder_correlation(y), na.rm = TRUE)
ggheatmap(y, t="Correlation of Features in the group of ela_conv")
}
ggheatmap(bfeats.cm_conv, t="Correlation of Features in the group of cm_conv")
cor.bfeats.cm_grad <- round(cor(bfeats.cm_grad),2)
cor.bfeats.cm_grad <- round(cor(bfeats.cm_grad),2)
cor.bfeats.cm_grad <- melt(reorder_correlation(cor.bfeats.cm_grad), na.rm = TRUE)
ggheatmap(cor.bfeats.cm_grad, t="Correlation of Features in the group of cm_grad")
cor.bfeats.cm_grad
heatmap <- function(x, t){
y <- round(cor(x),2)
y <- melt(reorder_correlation(y), na.rm = TRUE)
}
ggheatmap(bfeats.cm_conv, t="Correlation of Features in the group of cm_conv")
heatmap <- function(x, t){
y <- round(cor(x),2)
y <- melt(reorder_correlation(y), na.rm = TRUE)
ggheatmap(y, t="Correlation of Features in the group of ela_conv")
}
heatmap(bfeats.cm_angle, t="Correlation of Features in the group of cm_angle")
heatmap(cor.bfeats.ela_conv, t="Correlation of Features in the group of ela_conv")
heatmap(bfeats.ela_conv, t="Correlation of Features in the group of ela_conv")
# Create a ggheatmap
ggheatmap <- function(x, t){
ggplot(x, aes(Var2, Var1, fill = value))+
geom_tile(color = "white")+
scale_fill_gradient2(low = "blue", high = "red", mid = "white",
midpoint = 0, limit = c(-1,1), space = "Lab",
name="Pearson\nCorrelation") +
theme_minimal()+ # minimal theme
theme(axis.text.x = element_text(angle = 45, vjust = 1,
size = 12, hjust = 1))+
coord_fixed()+ #add correlation coefficients on the heatmap
geom_text(aes(Var2, Var1, label = value), color = "black", size = 3) +
theme(
axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.grid.major = element_blank(),
panel.border = element_blank(),
panel.background = element_blank(),
axis.ticks = element_blank(),
legend.justification = c(1, 0),
legend.position = c(0.4, 0.5),
legend.direction = "horizontal")+
guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
title.position = "top", title.hjust = 0.5))+
# Input title of the graph
ggtitle(t) + theme(plot.title = element_text(lineheight=.8, face="bold"))
}
heatmap(bfeats.ela_conv, t="Correlation of Features in the group of ela_conv")
# Create a ggheatmap
ggheatmap <- function(x, t){
ggplot(x, aes(Var2, Var1, fill = value))+
geom_tile(color = "white")+
scale_fill_gradient2(low = "blue", high = "red", mid = "white",
midpoint = 0, limit = c(-1,1), space = "Lab",
name="Pearson\nCorrelation") +
theme_minimal()+ # minimal theme
theme(axis.text.x = element_text(angle = 45, vjust = 1,
size = 12, hjust = 1))+
coord_fixed()+ #add correlation coefficients on the heatmap
geom_text(aes(Var2, Var1, label = value), color = "black", size = 3) +
theme(
axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.grid.major = element_blank(),
panel.border = element_blank(),
panel.background = element_blank(),
axis.ticks = element_blank(),
legend.justification = c(1, 0),
legend.position = c(0.2, 0.5),
legend.direction = "horizontal")+
guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
title.position = "top", title.hjust = 0.5))+
# Input title of the graph
ggtitle(t) + theme(plot.title = element_text(lineheight=.8, face="bold"))
}
heatmap(bfeats.ela_conv, t="Correlation of Features in the group of ela_conv")
ggheatmap <- function(x, t){
ggplot(x, aes(Var2, Var1, fill = value))+
geom_tile(color = "white")+
scale_fill_gradient2(low = "blue", high = "red", mid = "white",
midpoint = 0, limit = c(-1,1), space = "Lab",
name="Pearson\nCorrelation") +
theme_minimal()+ # minimal theme
theme(axis.text.x = element_text(angle = 45, vjust = 1,
size = 12, hjust = 1))+
coord_fixed()+ #add correlation coefficients on the heatmap
geom_text(aes(Var2, Var1, label = value), color = "black", size = 3) +
theme(
axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.grid.major = element_blank(),
panel.border = element_blank(),
panel.background = element_blank(),
axis.ticks = element_blank(),
legend.justification = c(1, 0),
legend.position = c(0.5, 0.8),
legend.direction = "horizontal")+
guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
title.position = "top", title.hjust = 0.5))+
# Input title of the graph
ggtitle(t) + theme(plot.title = element_text(lineheight=.8, face="bold"))
}
heatmap(bfeats.ela_conv, t="Correlation of Features in the group of ela_conv")
heatmap(bfeats.cm_angle, t="Correlation of Features in the group of cm_angle")
atmap
ggheatmap <- function(x, t){
ggplot(x, aes(Var2, Var1, fill = value))+
geom_tile(color = "white")+
scale_fill_gradient2(low = "blue", high = "red", mid = "white",
midpoint = 0, limit = c(-1,1), space = "Lab",
name="Pearson\nCorrelation") +
theme_minimal()+ # minimal theme
theme(axis.text.x = element_text(angle = 45, vjust = 1,
size = 12, hjust = 1))+
coord_fixed()+ #add correlation coefficients on the heatmap
geom_text(aes(Var2, Var1, label = value), color = "black", size = 3) +
theme(
axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.grid.major = element_blank(),
panel.border = element_blank(),
panel.background = element_blank(),
axis.ticks = element_blank(),
legend.justification = c(1, 0),
legend.position = c(0.5, 0.7),
legend.direction = "horizontal")+
guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
title.position = "top", title.hjust = 0.5))+
# Input title of the graph
ggtitle(t) + theme(plot.title = element_text(lineheight=.8, face="bold"))
}
heatmap(bfeats.cm_angle, t="Correlation of Features in the group of cm_angle")
heatmap(bfeats.ela_conv, t="Correlation of Features in the group of ela_conv")
heatmap(bfeats.ela_curv[,seq(1,7)], m="Correlation of Features in the group of ela_curv (extract)")
ggheatmap <- function(x, m){
ggplot(x, aes(Var2, Var1, fill = value))+
geom_tile(color = "white")+
scale_fill_gradient2(low = "blue", high = "red", mid = "white",
midpoint = 0, limit = c(-1,1), space = "Lab",
name="Pearson\nCorrelation") +
theme_minimal()+ # minimal theme
theme(axis.text.x = element_text(angle = 45, vjust = 1,
size = 12, hjust = 1))+
coord_fixed()+ #add correlation coefficients on the heatmap
geom_text(aes(Var2, Var1, label = value), color = "black", size = 3) +
theme(
axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.grid.major = element_blank(),
panel.border = element_blank(),
panel.background = element_blank(),
axis.ticks = element_blank(),
legend.justification = c(1, 0),
legend.position = c(0.5, 0.7),
legend.direction = "horizontal")+
guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
title.position = "top", title.hjust = 0.5))+
# Input title of the graph
ggtitle(m) + theme(plot.title = element_text(lineheight=.8, face="bold"))
}
heatmap(bfeats.ela_curv[,seq(1,7)], m="Correlation of Features in the group of ela_curv (extract)")
heatmap(bfeats.ela_conv, m="Correlation of Features in the group of ela_conv")
ggheatmap <- function(x, m){
ggplot(x, aes(Var2, Var1, fill = value))+
geom_tile(color = "white")+
scale_fill_gradient2(low = "blue", high = "red", mid = "white",
midpoint = 0, limit = c(-1,1), space = "Lab",
name="Pearson\nCorrelation") +
theme_minimal()+ # minimal theme
theme(axis.text.x = element_text(angle = 45, vjust = 1,
size = 12, hjust = 1))+
coord_fixed()+ #add correlation coefficients on the heatmap
geom_text(aes(Var2, Var1, label = value), color = "black", size = 3) +
theme(
axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.grid.major = element_blank(),
panel.border = element_blank(),
panel.background = element_blank(),
axis.ticks = element_blank(),
legend.justification = c(1, 0),
legend.position = c(0.5, 0.7),
legend.direction = "horizontal")+
guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
title.position = "top", title.hjust = 0.5))+
# Input title of the graph
ggtitle(m) + theme(plot.title = element_text(lineheight=.8, face="bold"))
}
heatmap(bfeats.cm_conv, m="Correlation of Features in the group of cm_conv")
heatmap(bfeats.cm_angle, m="Correlation of Features in the group of cm_angle")
##Aggregated function for ggheatmap to use function with only one command
heatmap <- function(x, m){
y <- round(cor(x),2)
y <- melt(reorder_correlation(y), na.rm = TRUE)
ggheatmap(y, t="Correlation of Features in the group of ela_conv")
}
heatmap(bfeats.ela_curv[,seq(1,7)], m="Correlation of Features in the group of ela_curv (extract)")
heatmap <- function(x, m){
y <- round(cor(x),2)
y <- melt(reorder_correlation(y), na.rm = TRUE)
ggheatmap(y, m)
}
heatmap(bfeats.ela_curv[,seq(1,7)], m="Correlation of Features in the group of ela_curv (extract)")
pairs.custom(bfeats.ela_curv[,seq(1,7)], m="Correlation of Features in the group of ela_curv (extract)")
pairs.custom(bfeats.ela_curv, m="Correlation of Features in the group of ela_curv (extract)")
pairs.custom(bfeats.ela_curv[,seq(1,7)], m="Correlation of Features in the group of ela_curv (extract)")
heatmap(bfeats.ela_curv[,c(1,8,15)], m="Correlation of Features in the group of ela_curv (extract)")
pairs.custom(bfeats.ela_curv[,c(1,8,15)], m="Correlation of Features in the group of ela_curv (extract)")
pairs.custom(bfeats.ela_local, m="Correlation of Features in the group of ela_local")
pairs.custom(bfeats.ela_local[,c(6,7,8,9,10,11,12,13)], m="Correlation of Features in the group of ela_local (extract)")
heatmap(bfeats.ela_local[,c(6,7,8,9,10,11,12,13)], m="Correlation of Features in the group of ela_local (extract)")
heatmap(data.frame(ela_conv.costs_runtime=bfeats.ela_conv[,4],
ela_curv.costs_runtime=bfeats.ela_curv[,23],
ela_local.costs_runtime=bfeats.ela_local[,14],
peak=metadata[,4]), m="Correlation of the number of peaks with ELA runtime")
pairs.custom(data.frame(ela_conv.costs_runtime=bfeats.ela_conv[,4],
ela_curv.costs_runtime=bfeats.ela_curv[,23],
ela_local.costs_runtime=bfeats.ela_local[,14],
peak=metadata[,4]), m="Correlation of the number of peaks with ELA runtime")
pairs.custom(bfeats.cm_conv, m="Correlation of Features in the group of cm_conv", col=colors[metadata[,6]])
princomp_feat_groups = data.frame(
bfeats.topology,
princomp(bfeats.cm_angle, corr=TRUE, scores=TRUE)$scores[,1],
princomp(bfeats.cm_conv, corr=TRUE, scores=TRUE)$scores[,1],
princomp(bfeats.cm_grad, corr=TRUE, scores=TRUE)$scores[,1],
princomp(bfeats.ela_conv, corr=TRUE, scores=TRUE)$scores[,1],
princomp(bfeats.ela_curv, corr=TRUE, scores=TRUE)$scores[,1],
princomp(bfeats.ela_local, corr=TRUE, scores=TRUE)$scores[,1])
summary(princomp_feat_groups)
summary(princomp(bfeats.cm_angle, corr=TRUE, scores=TRUE))  #93.30%
summary(princomp(bfeats.cm_conv, corr=TRUE, scores=TRUE))  #73.38%
summary(princomp(bfeats.cm_grad, corr=TRUE, scores=TRUE))  #95.55%
summary(princomp(bfeats.ela_conv, corr=TRUE, scores=TRUE))  #99.99%
summary(princomp(bfeats.ela_curv, corr=TRUE, scores=TRUE))  #60.06%
colnames(princomp_feat_groups) <- c("topology", "cm_angle", "cm_conv", "cm_curv", "ela_conv", "ela_curv", "ela_local")
pairs.custom(princomp_feat_groups, m="Correlation between Feature Groups")
pairs.cor(princomp_feat_groups)   #0.3365  correlation of certain groups drives overall correlation
heatmap(princomp_feat_groups, m="Correlation between Feature Groups")
pairs.custom(princomp_feat_groups[2:4], m="Correlation between Feature Groups", color=colors[metadata[,1]],
legend.title="Number of blocks", legend.text=c("3 blocks", "5 blocks", "7 blocks"),
legend.col = colors[c(3,5,7)])
scatterplot3d.custom(bfeats.cm_angle[,1], bfeats.cm_angle[,3], bfeats.cm_angle[,7],
angle=35, main="3D Scatterplot on features within cm_angle", xlab="dist_ctr2best.mean", ylab="dist_ctr2worst.mean",
zlab="y_ratio_best2worst.mean", col=colors[metadata[,1]], legend.title="Number of blocks",
legend.text=c("3 blocks", "5 blocks", "7 blocks"), legend.col=colors[c(3,5,7)])
scatterplot3d.custom(bfeats.cm_angle[,7], bfeats.cm_conv[,4], bfeats.cm_grad[,1],
angle=35, main="3D Scatterplot on features within CM", xlab="y_ratio_best2worst.mean", ylab="concave.soft",
zlab="cm_grad.mean", col=colors[metadata[,1]], legend.title="Number of blocks",
legend.text=c("3 blocks", "5 blocks", "7 blocks"), legend.col=colors[c(3,5,7)])
#runtimes within ELA feature are commonly increasing(depending on number of peaks)
scatterplot3d.custom(bfeats.ela_conv[,4], bfeats.ela_curv[,23], bfeats.ela_local[,14],
angle=35, main="3D Scatterplot on runtime features within ela features", xlab="ela_conv.runtime", ylab="ela_curv.runtime",
zlab="ela_local.runtime",col=colors[metadata[,4]/20], legend.col=colors[1:10],
legend.title = "Number of peaks", legend.text = c("20 peaks", "40 peaks", "60 peaks",
"80 peaks", "100 peaks", "120 peaks", "140 peaks", "160 peaks","180 peaks", "200 peaks"))
#dependencies within ELA_curv featureset
scatterplot3d.custom(bfeats.ela_curv[,3], bfeats.ela_curv[,10], bfeats.ela_curv[,17],
angle=35, main="3D Scatterplot on features within ela_curv features", xlab="grad_norm.mean", ylab="grad_scale.mean",
zlab="hessian_cond.mean", col=colors[bfeats.topology], legend.title="Topology",
legend.text=c("funnel", "random"), legend.col=colors[1:2])
#also between ELA features there are some dependencies. clusters are dependent upon the topology of function
scatterplot3d.custom(bfeats.ela_conv[,1], bfeats.ela_curv[,3], bfeats.ela_local[,3],
angle=35, main="3D Scatterplot between features within ela features (by topology)", xlab="ela_conv.conv_prob", ylab="ela_curv.grad_norm.mean",
zlab="ela_local.basin_sizes.avg_best", col=colors[bfeats.topology], legend.title="Topology",
legend.text=c("funnel", "random"), legend.col=colors[1:2])
n the topology of function
scatterplot3d.custom(bfeats.ela_conv[,1], bfeats.ela_curv[,4], bfeats.ela_local[,6],
angle=35, main="3D Scatterplot between features within ela features (by topology)", xlab="ela_conv.conv_prob", ylab="ela_curv.grad_norm.mean",
zlab="ela_local.basin_sizes.avg_best", col=colors[bfeats.topology], legend.title="Topology",
legend.text=c("funnel", "random"), legend.col=colors[1:2])
n the topology of function
scatterplot3d.custom(bfeats.ela_conv[,2], bfeats.ela_curv[,1], bfeats.ela_local[,3],
angle=35, main="3D Scatterplot between features within ela features (by topology)", xlab="ela_conv.conv_prob", ylab="ela_curv.grad_norm.mean",
zlab="ela_local.basin_sizes.avg_best", col=colors[bfeats.topology], legend.title="Topology",
legend.text=c("funnel", "random"), legend.col=colors[1:2])
scatterplot3d.custom(princomp_feat_groups$ela_conv, princomp_feat_groups$ela_curv, princomp_feat_groups$ela_local,
angle=35, main="3D Scatterplot on ELA-features", xlab="ela_conv",
ylab="ela_curv", zlab="ela_local",col=colors[1], legend.title="no", legend.col=NULL, legend.text=NULL)
scatterplot3d.custom(princomp_feat_groups$ela_conv, princomp_feat_groups$ela_curv, princomp_feat_groups$ela_local,
angle=35, main="3D Scatterplot on ELA-features (prob.seed)", xlab="ela_conv",
ylab="ela_curv", zlab="ela_local",col=colors[metadata[,5]], legend.col=colors[1:5],
legend.title = "Prob.seed", legend.text = c("1", "2", "3", "4", "5"))
scatterplot3d.custom(princomp_feat_groups$ela_conv, princomp_feat_groups$ela_curv, princomp_feat_groups$ela_local,
angle=35, main="3D Scatterplot on ELA-features (the number of peaks)", xlab="ela_conv",
ylab="ela_curv", zlab="ela_local",col=colors[metadata[,4]/20], legend.col=colors[1:10],
legend.title = "Number of peaks", legend.text = c("20 peaks", "40 peaks", "60 peaks",
"80 peaks", "100 peaks", "120 peaks", "140 peaks", "160 peaks","180 peaks", "200 peaks"))
scatterplot3d.custom(princomp_feat_groups$cm_angle, princomp_feat_groups$cm_conv, princomp_feat_groups$cm_grad,
angle=55, main="3D Scatterplot on CM-features", xlab="cm_angle",
ylab="cm_conv", zlab="cm_grad",col=colors[1], legend.title="no", legend.col=NULL, legend.text=NULL)
#adding the information of how many blocks were created shows up three distinct clusters
scatterplot3d.custom(princomp_feat_groups$cm_angle, princomp_feat_groups$cm_conv, princomp_feat_groups$cm_grad,
angle=55, main="3D Scatterplot on CM-features (by the number of blocks)", xlab="cm_angle",
ylab="cm_conv", zlab="cm_grad", col=colors[metadata[,1]], legend.title="Number of blocks",
legend.text=c("3 blocks", "5 blocks", "7 blocks"), legend.col=colors[c(3,5,7)])
cor.detect(bfeats)
cor.detect(bfeats, l=.9)
